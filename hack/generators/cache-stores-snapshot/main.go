package main

import (
	"bytes"
	"os"
	"reflect"
	"text/template"

	"github.com/kong/kubernetes-ingress-controller/v3/internal/store"
)

// This code generates `store.CacheStores.TakeSnapshot` method.

const (
	outputFile = "zz_generated_cache_stores_snapshot.go"

	outputTemplate = `// Code generated by hack/generators/cache/snapshot.go; DO NOT EDIT.
package store

import (
	"fmt"

	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/tools/cache"
)

func (c CacheStores) TakeSnapshot() (CacheStores, error) {
	// Create a fresh CacheStores instance to store the snapshot.
	snapshot := NewCacheStores()

	// Gather cache store fields for all kinds.
	allStores := []cache.Store{
		{{- range . }}
		c.{{ . }},
		{{- end }}
	}

	c.l.RLock()
	defer c.l.RUnlock()

	// Iterate over all stores and add a deep copy of each object to the snapshot.
	for _, store := range allStores {
		for _, item := range store.List() {
			obj, ok := item.(runtime.Object)
			if !ok {
				return CacheStores{}, fmt.Errorf("expected runtime.Object, got %T", item)
			}

			copiedObj := obj.DeepCopyObject()
			if err := snapshot.Add(copiedObj); err != nil {
				return CacheStores{}, err
			}
		}
	}

	return snapshot, nil
}
`
)

func main() {
	cacheStoresType := reflect.TypeOf(store.CacheStores{})
	var storesFieldsNames []string
	for i := 0; i < cacheStoresType.NumField(); i++ {
		field := cacheStoresType.Field(i)
		// Only collect fields of `Store` type as `CacheStores` may include other ones (e.g. a mutex).
		if field.Type.Name() == "Store" {
			storesFieldsNames = append(storesFieldsNames, field.Name)
		}
	}

	tpl, err := template.New("output").Parse(outputTemplate)
	if err != nil {
		panic(err)
	}

	contents := &bytes.Buffer{}
	if err := tpl.Execute(contents, storesFieldsNames); err != nil {
		panic(err)
	}

	if err := os.WriteFile(outputFile, contents.Bytes(), 0o600); err != nil {
		panic(err)
	}
}
