package main

import (
	"bytes"
	"os"
	"reflect"
	"text/template"

	"github.com/kong/kubernetes-ingress-controller/v3/internal/store"
)

// This code generates `fallback.NewConfigGraphFromCacheStores` function.

const (
	outputFile = "zz_generated_graph.go"

	outputTemplate = `// Code generated by hack/generators/config-graph; DO NOT EDIT.
package fallback

import (
	"errors"
	"fmt"

	"github.com/dominikbraun/graph"
	"github.com/kong/kubernetes-ingress-controller/v3/internal/store"
	"k8s.io/client-go/tools/cache"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

func NewConfigGraphFromCacheStores(c store.CacheStores) (*ConfigGraph, error) {
	g := graph.New[ObjectHash, client.Object](GetObjectHash, graph.Directed())

	// Gather cache store fields for all kinds.
	allStores := []cache.Store{
		{{- range . }}
		c.{{ . }},
		{{- end }}
	}

	for _, s := range allStores {
		for _, o := range s.List() {
			obj, err := o.(client.Object)
			if !err {
				// Should not happen since all objects in the cache are client.Objects, but better safe than sorry.
				return nil, fmt.Errorf("expected client.Object, got %T", o)
			}
			// Add the object to the graph. It can happen that the object is already in the graph (i.e. was already added
			// as a dependency of another object), in which case we ignore the error.
			if err := g.AddVertex(obj); err != nil && !errors.Is(err, graph.ErrVertexAlreadyExists) {
				return nil, fmt.Errorf("failed to add %s to the graph: %w", GetObjectHash(obj), err)
			}

			// Add the object's dependencies to the graph.
			for _, dep := range ResolveDependencies(c, obj) {
				// Add the dependency to the graph in case it wasn't added before. If it was added before, we ignore the
				// error.
				if err := g.AddVertex(dep); err != nil && !errors.Is(err, graph.ErrVertexAlreadyExists) {
					return nil, fmt.Errorf("failed to add %s to the graph: %w", GetObjectHash(obj), err)
				}

				// Add an edge from a dependency to the object. If the edge was already added before, we ignore the error.
				if err := g.AddEdge(GetObjectHash(dep), GetObjectHash(obj)); err != nil && !errors.Is(err, graph.ErrEdgeAlreadyExists) {
					return nil, fmt.Errorf("failed to add edge from %s to %s: %w", GetObjectHash(obj), GetObjectHash(dep), err)
				}
			}
		}
	}

	return &ConfigGraph{graph: g}, nil
}
`
)

func main() {
	cacheStoresType := reflect.TypeOf(store.CacheStores{})
	var storesFieldsNames []string
	for i := 0; i < cacheStoresType.NumField(); i++ {
		field := cacheStoresType.Field(i)
		// Only collect fields of `Store` type as `CacheStores` may include other ones (e.g. a mutex).
		if field.Type.Name() == "Store" {
			storesFieldsNames = append(storesFieldsNames, field.Name)
		}
	}

	tpl, err := template.New("output").Parse(outputTemplate)
	if err != nil {
		panic(err)
	}

	contents := &bytes.Buffer{}
	if err := tpl.Execute(contents, storesFieldsNames); err != nil {
		panic(err)
	}

	if err := os.WriteFile(outputFile, contents.Bytes(), 0o600); err != nil {
		panic(err)
	}
}
